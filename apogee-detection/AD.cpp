/*The purpose of this script is to test the effectiveness of our apogee detection 
algorithm on SIMULATED DATA. This is not intended for use on hardware.
If you're looking for code to use on the board you want 'apogee-task.c' and 'apogee-task.h'
For AD.cpp to work you need to have noise_generator.hpp and noise_generator.cpp in your directory.

You will also need height and acceleration data, which can be generated by MASTRAN.                                                                                             
Get this by:  
1) running MASTRAN
2) exporting the variables from the simulation to the workspace
3) copy/paste from the Xs field (row 11) for height data into a .txt 
4) copy/past from the Ps field (row 36) for acceleration data into a .txt

Or just use the a_x_data_new.txt and height_data_new.txt files in this repo for 
the data from the most recent sim I ran. 

Carefully monitor the terminal output to see how the algorithm behaves, OR wait until 
the entire program executes (5 minutes or more) to see the flight summary output 
that prints to flight_summary.txt

If you're having trouble figuring out how to get up-to-date flight sim data out of MASTRAN 
email pickos@umich.edu OR the current A&R team lead. 
*/

#include <iostream>
#include <vector>
#include <random>
#include <ctime>
#include <chrono>
#include <thread>
#include <fstream>
#include <string>
#include <cmath>

#include <numeric>
#include <iterator>
#include <iomanip>

#include "noise_generator.hpp"
#include "speed_LUT.h"

using namespace std;

struct Program_Info
{
    int flight_style = -1;
    int baro_size = -1;
    int imu_size = -1;
    int detection_method = -1;
    bool MECO_flag = false;
    bool apogee_flag = false;
    bool drogue_flag = false;
    bool main_flag = false;
    bool flight_over = false;
};

struct Device_Package
{
    Barometer baro_1;
    Barometer baro_2;
    std::pair<int, int> baro1_D1_D2;
    std::pair<int, int> baro2_D1_D2;
};

//used post-MECO to compute 'wait-time' for phase 2
struct BallisticParams 
{
    double A = 0.08; //cross sectional area of rocket       
    double m = 255;  //post-MECO mass (kg)
    double Cd_const = 0.5; // (keeping constant for now)
};

//this information will print to the flight_summary.txt file after the program finishes
struct Flight_Summary
{
    double MECO_time = -1;
    double MECO_altitude = -1;
    double MECO_speed = -1;
    double MECO_mach_num = -1;
    double wait_time = -1;
    double apogee_time = -1;
    double apogee_altitude = -1;
    double drogue_altitude = -1;
    double main_altitude = -1;
};

class Detector
{
    public: 

    Detector(const int CAP_IN, bool is_baro) : CAPACITY(CAP_IN), is_baro(is_baro)
    {
        readings_1 = new double[CAPACITY];
        readings_2 = new double[CAPACITY];
        average = new double[CAPACITY];
        slope = new double[CAPACITY];
    };

    ~Detector()
    {
        delete[] readings_1;
        delete[] readings_2;
        delete[] average;
        delete[] slope;
    }

    const int CAPACITY;
    bool is_baro;
    double*readings_1;
    double*readings_2;
    double*average;
    double*slope;

    //buffer for readings from barometer 2 
    int index_1 = 0;
    int size_1 = 0;

    //buffer for readings from barometer 2
    int index_2 = 0;
    int size_2 = 0;

    //buffer for the average of the two barometers
    int avg_index = 0;
    int avg_size = 0;

    //buffer for the 'slope' or how the average of the barometer readings 
    //changes over time
    int slope_i = 0;
    int slope_size = 0;

    //just a basic mean. WATCH OUT for integer division!
    double mean(int size, double * arr)
    {
        if (size == 0)
            return 0;
        double sum = std::accumulate(arr, arr + size, 0.0);
        return sum / static_cast<double>(size);
    }

    //The premise of 'insert':
    //•Circular buffers -> necessary so we don't use up all the memory on the microcontroller. 
    //•Two barometers -> we want to take a moving / smoothed out average of the 2 readings. 
    void insert(double baro1, double baro2, Program_Info &info)
    {
        //this technique is called imputation! 
        //if we receive a bad reading, we don't want to corrupt the average.
        //to prevent this: if we detect nan or infinite, we take the mean of the readings 
        //CURRENTLY IN THE BUFFER, and insert that number into the place where 
        //NAN would have been inserted. 
            
        if(std::isnan(baro1) || !std::isfinite(baro1) || (is_baro && (baro1 <= 0 || baro1 >= 2000))){
            baro1 = mean(size_1, readings_1);}
        readings_1[index_1] = baro1;
        index_1++;
        index_1 = index_1 % CAPACITY;
        size_1 = std::min(size_1 + 1, CAPACITY);

        //same as above!
        if(std::isnan(baro2) || !std::isfinite(baro2) || (is_baro && (baro2 <= 0 || baro2 >= 2000))){
            baro2 = mean(size_2, readings_2);}
        readings_2[index_2] = baro2;
        index_2++;
        index_2 = index_2 % CAPACITY;
        size_2 = std::min(size_2 + 1, CAPACITY);

        average[avg_index] = (mean(size_1, readings_1) + mean(size_2, readings_2)) / 2;
        avg_index++;
        avg_index = avg_index % CAPACITY;
        avg_size = std::min(avg_size + 1, CAPACITY);



        //Wait until the 'average' buffer is full to start computing the slopes
        if(avg_size >= CAPACITY)
        {
            ////this 'if' block controls the detection of the steep drop in acceleration for IMUs (or just basic barometer handling)
            //if negative acceleration MECO detection was selected this block should be skipped  

            //example using step size of 5
            //Compare the MOST RECENT average reading to the reading from 5 STEPS ago
            //Our whole windows is size 5 so this effectively gives an estimate of the 
            //average change per step over our whole window
    
            //For example if our 'average' buffer is [2 3 5 9 8] and avg_index is currently 0.
            //This means the most recent reading will have been placed at avg_index 4 (becuase we've
            //now wrapped around to the start of our buffer by the time we reach this block) 

            //0 + 5 - 1 = 4 (most recent reading) average[4] = 8
            //0 + 5 - 5 = 0 (oldest reading) average[0] = 2
            //(8 - 2) / 5 = 1.2 
            //So we can estimate that our average change was roughly 1.2 per step over this window.
            if(info.detection_method == 2 || info.flight_style == 2 || info.MECO_flag == true)
            {
                slope[slope_i] = (average[(avg_index + CAPACITY - 1) % CAPACITY ] - 
                    average[(avg_index + CAPACITY - CAPACITY) % CAPACITY]) / CAPACITY;
            
                // std::cout << slope[slope_i] << "\n";
                slope_size = std::min(slope_size + 1, CAPACITY);
                slope_i = (slope_i + 1) % CAPACITY;
            }

            if(info.flight_style == 1 && info.detection_method == 1 && info.MECO_flag == false)
                std::cout << "Accleration : " << average[avg_index] << "\n";

        }
    }

    bool is_buffer_average_less_than_this_value(double search_value)
    {
        if (avg_size < CAPACITY)
            return false;
        else
        {
            int count = 0;
            for (int i = 0; i < CAPACITY; ++i)
            {
                if (average[i] < search_value)
                    ++count;
            }
            if (count >= (CAPACITY * 0.8))
                return true;
        }
        return false;
    }

    bool is_buffer_average_greater_than_this_value(double search_value)
    {
        if (avg_size < CAPACITY)
            return false;
        else
        {
            int count = 0;
            for (int i = 0; i < CAPACITY; ++i)
            {
                if (average[i] > search_value)
                    ++count;
            }
            if (count >= (CAPACITY * 0.8))
                return true;
        }
        return false;
    }

    bool detect_apog(Program_Info &info)
    {
        if(info.apogee_flag == false)
        {
            if (slope_size < CAPACITY)
                return false;
            else
            { 
                int count = 0;
                for(int i = 0; i < CAPACITY; ++i)
                {
                    if(slope[i] > 0)
                        ++count;
                }

                //if 80% of the readings in our slope buffer are positive DETECT APOGEE
                if(count >= (CAPACITY * 0.8))
                    return true;
            }
        }
        else if (info.apogee_flag == true && info.drogue_flag == false)
        {
            return is_buffer_average_greater_than_this_value(825); //approximate pressure in hPa at 1500 m
        }

        else if(info.apogee_flag == true && info.drogue_flag == true && info.main_flag == false)
        {
            return is_buffer_average_greater_than_this_value(975); //aproximate pressure in hPa at 300 m 
        }

        return false;
    }

    bool detect_MECO(Program_Info &info)
    {
        //for steep drop detection
        //WARNING! MAGIC NUMBER USED HERE. Works for window size 5 on OUR CURRENT SIMULATED DATA 
        //Very possibly safer to simply search for 'negative acceleration' in real flight, as that  
        //should work across many different flight scenarios! 
        if (info.detection_method == 2)
        {
            if (slope_size < CAPACITY)
                return false;
            else
            {
                int count = 0;
                for (int i = 0; i < CAPACITY; ++i)
                {
                    //this number works best for window size 5
                    if (slope[i] < -0.2475)
                        ++count;
                }

                // if 80% of the readings in our slope buffer are less than -0 DETECT MECO
                if (count >= (CAPACITY * 0.8))
                    return true;
            }
            return false;
        }

        //for negative acceleration detection
        else if(info.detection_method == 1)
        {
            return is_buffer_average_less_than_this_value(0);
        }


        return false;
    }
    
};

void read_detect_decide(int j, double current_height, Device_Package &device_package, 
        Program_Info &info, Detector &detect, Environment &env, Flight_Summary &summary)
{
        // if (/*current_height > 17000 ||*/ info.apogee_flag == true)
        if (info.MECO_flag == true || info.apogee_flag == true || info.flight_style == 2)
        {
            double P_true = env.compute_pressure(current_height);
            double T_true = env.compute_temp(current_height);

            // inject noise
            double P_noisy_1 = P_true + gaussian_random(0, 1.5);
            double T_noisy_1 = T_true + gaussian_random(0, 8);

            double P_noisy_2 = P_true + gaussian_random(0, 1.5);
            double T_noisy_2 = T_true + gaussian_random(0, 8);

            device_package.baro1_D1_D2 = device_package.baro_1.guess_and_check(P_noisy_1, T_noisy_1);
            device_package.baro2_D1_D2 = device_package.baro_2.guess_and_check(P_noisy_2, T_noisy_2);

            auto [baro1_final_P, baro1_final_TEMP] = 
                device_package.baro_1.forward_calculation(device_package.baro1_D1_D2.first, device_package.baro1_D1_D2.second);

            auto [baro2_final_P, baro2_final_TEMP] = 
                device_package.baro_2.forward_calculation(device_package.baro2_D1_D2.first, device_package.baro2_D1_D2.second);

            cout << "\n";
            cout << setw(10) << left << current_height;
            cout << setw(10) << left << baro1_final_P / 100 << setw(10) << left << baro2_final_P / 100;

            cout << setw(10) << left << static_cast<double>(j) / 100;

            if (detect.size_1 < 5 && detect.size_2 < 5)
            {
                detect.insert(baro1_final_P / 100, baro2_final_P / 100, info);
                // cout << setw(10) << left << "...loading\n";
            }
            else
            {
                detect.insert(baro1_final_P / 100, baro2_final_P / 100, info);

                if (detect.detect_apog(info))
                {
                    if (info.apogee_flag == false)
                    {
                        cout << "Apogee Detected!\n";
                        cout << "Beginning phase 3\n";
                        info.apogee_flag = true;

                        summary.apogee_time = static_cast<double>(j) / 100;
                        summary.apogee_altitude = current_height;
                        
                    }

                    else if(info.apogee_flag == true && info.drogue_flag == false)
                    {
                        cout << "1500 meters, deploy drogue!\n";
                        info.drogue_flag = true;

                        summary.drogue_altitude = current_height;
                    }

                    else if(info.apogee_flag == true && info.drogue_flag == true && info.main_flag == false)
                    {
                        cout << "300 meters, deploy main!\n";
                        info.main_flag = true;

                        summary.main_altitude = current_height;
                    }
                }
            }
        }
}

// called by 'wait_time_peicewise' function to help compute post-MECO wait-time! 
// advance one chunk, updating h and v; returns time used in this chunk
static double advance_chunk(Environment &env, const BallisticParams &bp, double &h, double &v, double chunk_dt)
{
    const double g = 9.80665;
    const double local_s_of_s  = env.speed_of_sound(h);

    // const double M_loc  = std::fabs(v) / a_loc;
    // const double Cd     = (bp.Cd_const > 0.0) ? bp.Cd_const : cd_from_mach(M_loc);

    const double Cd = 0.5;
    const double rho = env.compute_rho(h); // air density           
    const double drag_accel_coeff = std::max(1e-9, 0.5 * rho * Cd * bp.A / bp.m); // guard

    // Helper lambdas for closed-form v(t)
    const double s      = std::sqrt(drag_accel_coeff/g);
    const double omega  = std::sqrt(g*drag_accel_coeff);

    //CLOSED FORM SOLUTION to dv/dt = -g -(drag_coeff_accel)v^2
    //Since we are precomputing drag_coeff_accel once per chunk, we treat it as constant.
    //This simplifies the above differential equation allowing us to come to this clean
    //solution that we can simply evaluate once per chunk! 
    //*******************************************************/
    auto vel_at = [&](double t){ return std::sqrt(g/drag_accel_coeff) * std::tan(std::atan(s*v) - omega*t); };
    //*******************************************************/

    // Time (with this drag_accel_coeff) to drop to local Mach 1 speed
    //This is just solving the above closed form solution for t 
    const double t_to_mach = std::max(0.0, (std::atan(s*v) - std::atan(s*local_s_of_s)) / omega);

    // Use at most chunk_dt this pass
    const double t_used = std::min(chunk_dt, t_to_mach);
    const double v_new  = vel_at(t_used);

    // Altitude update: trapezoid (good within a short chunk)
    const double dh = 0.5 * (v + v_new) * t_used;

    //Update 
    h += dh;
    v  = v_new;
    return t_used; // caller decides if we reached Mach 1
}

//computes wait_time post-MECO to arm the barometers 
//lets us know when we drop sub-sonic
double wait_time_piecewise(Environment &env, const BallisticParams &bp, double h0, double v0, 
                            double chunk_dt = 0.5,   // 0.5–1.0 s is a good chunk size
                            double max_time = 60.0)  // safety cap
{
    double t_tot = 0.0, h = h0, v = v0;

    // quick exit if already subsonic
    if (std::fabs(v) <= env.speed_of_sound(h)) 
        return 0.0;

    for (int i = 0 ; i < (int)std::ceil(max_time/chunk_dt); ++i){
        
        // If we would already be subsonic at the start of a chunk, stop.
        const double local_s_of_s = env.speed_of_sound(h);
        if (std::fabs(v) <= local_s_of_s) 
            break;

        double used = advance_chunk(env, bp, h, v, chunk_dt);
        t_tot += used;

        // If we hit Mach within this chunk (used < chunk_dt), stop.
        if (used + 1e-9 < chunk_dt) 
            break;
    }
    return t_tot;
}

void write_output_file(Program_Info &info, Flight_Summary &summary)
{
    ofstream out("flight_summary.txt");

    if(out)
    {
            out << "===Flight Summary===\n";
            if(summary.MECO_time != -1)
            {
                out << "MECO detection time (s): " << summary.MECO_time << "\n";
                out << "MECO detection altitude (m): " << summary.MECO_altitude << "\n";
                out << "Estimated speed at MECO altitude (m/s): " << summary.MECO_speed << "\n";
                out << "Mach number at MECO: " << summary.MECO_mach_num << "\n";
                out << "Wait time until phase two (s): " << summary.wait_time << "\n";
            }
            else{
                out << "MECO not detected.\n";}
            
            if(summary.apogee_time != -1)
            {
                out << "Apogee detection time (s): " << summary.apogee_time << "\n";
                out << "Apogee detection altitude (m): " << summary.apogee_altitude << "\n";
            } 
            else{ 
                out << "Apogee not detected.\n";}

            if (summary.drogue_altitude != -1)
            {
                out << "Drogue chute detection altitude (m): " << summary.drogue_altitude << "\n";
            }
            else {
                out << "Drogue chute not triggered.\n";}

            if (summary.main_altitude != -1)
            {
                out << "Main chute detection altitude (m): " << summary.main_altitude << "\n";
            } 
            else {
                out << "Main chute not triggered.\n";}            
    }
    else{
        cerr << "Flight_summary.txt failed to open for writing.\n";
    }
}

void launch()
{
    Environment env;
    Program_Info info;
    Device_Package device_package;
    Flight_Summary summary;

    int MECO_time = 0;

    cout << "Enter a 'flight style': supersonic (1) or subsonic (2)\n";
    cout << "Option 1 uses IMUs to detect MECO, computes time to drop below Mach 1, then arms barometers for apogee detection.\n";
    cout << "Option 2 uses barometers for the entire flight.\n";
    cout << "Selection: ";  
    
    while(!(std::cin >> info.flight_style) || (info.flight_style != 1 && info.flight_style != 2))
    {
        std::cin.clear();
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        cout << "\nInvalid selection\nSupersonic (1) or subsonic (2)\n";
        cout << "Selection: ";
    }
    
    cout << "What window size for the barometers? (5 is a good default)\n";

    while (!(std::cin >> info.baro_size) || info.baro_size < 3 || info.baro_size > 1000)
    {
        std::cout << "Bad selection. Enter a number between 3 and 1000: ";
        std::cin.clear();
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    }

    //creating a detector for the barometers with a window of baro_size
    Detector detect(info.baro_size, true);

    if (info.flight_style == 1)
    {
        cout << "What window size for the IMUs? (5 is a good default)\n";

        while ((!(std::cin >> info.imu_size)) || (info.imu_size < 3 || info.imu_size > 1000))
        {
            cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            cout << "Bad selection. Enter a number between 3 and 1000: ";
        }

        cout << "What detection method? Search for negative acceleration (recommended), or look for steep drop in acceleration? 1 or 2\n";

        while((!(std::cin >> info.detection_method)) || (info.detection_method != 1 && info.detection_method != 2))
        {
            cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            cout << "\nInvalid selection\nNegative acceleration (1) or steep drop (2)\n";
            cout << "Selection: ";
        }

        //creating a detector for the IMU with a window of imu_size
        Detector detect_IMU(info.imu_size, false);

        //read in data for IMUs to detect MECO
        std::ifstream FS_1("a_x_data_new.txt");
        std::vector<long double> a_x_data;
        string a_x;

        while (FS_1 >> a_x)
            a_x_data.push_back(std::stold(a_x));

        FS_1.close();

        //IMUs are armed from the ground. 
        //Once MECO is detected logic is passed off to the barometers after some predetermined time    
        //new code for MECO detection

        int i = 0;
        
        while(info.MECO_flag == false && i < a_x_data.size())
        {

            double current_a_x = a_x_data[i];

            //inject noise
            //need to determine how much noise to inject to make this realistic
            //that can be found in the IMU datasheet. 
            //for now, just using the same noise as the barometers
            double a_x_noisy_1 = (current_a_x + gaussian_random(0, 1.5)) / 9.8;
            double a_x_noisy_2 = (current_a_x + gaussian_random(0, 1.5)) / 9.8;

            if (detect_IMU.size_1 < 5 && detect_IMU.size_2 < 5)
                {
                    detect_IMU.insert(a_x_noisy_1, a_x_noisy_2, info);
                }
                else
                {

                    cout << "Time: " << left << setw(5) << static_cast<double>(i) / 100 << "   |   ";

                    detect_IMU.insert(a_x_noisy_1, a_x_noisy_2, info);

                    if (detect_IMU.detect_MECO(info) && info.MECO_flag == false)
                    {
                        cout << "MECO Detected!\n";
                        cout << "Wait to drop below Mach 1...\n";
                        cout << "Beginning phase 2 with barometers\n";
                        info.MECO_flag = true;
                        MECO_time = i;
                        summary.MECO_time = i / 100;
                    }
                }
                //just using this index variable to cycle through 
                //the array data from the a_x_data.txt file
                ++i;
        }

        if (info.MECO_flag == false)
            cout << "MECO not detected!\n";

    }    

    //read in altidude data for barometers to detect apogee after MECO
    std::ifstream FS_2("height_data_new.txt");
    std::vector<long double> heights;
    string height;

    while (FS_2 >> height)
        heights.push_back(std::stold(height));

    FS_2.close();

    //iteration variable for phase 2. 
    //its value will be greater than zero if the follow if-block executes
    //but should stay at zero if user selected barometer-only before running program
    int j = 0;

    if(info.flight_style == 1)
    {
        //calculate the wait time before phase 2
        cout << "MECO detected at approximately: " << heights[MECO_time] << " meters\n";
        summary.MECO_altitude = heights[MECO_time];

        //BREAKS if MECO_time happens after 30 seconds for the current LUT. 
        //If you want longer times get a bigger LUT (good), or clamp this to the biggest 
        //table index (less good, answer will be wrong)
        double current_speed = speed_LUT[static_cast<int>(MECO_time / 25)];
        summary.MECO_speed = current_speed;

        cout << "Estimated speed at this altitude is: " << current_speed << " m/s\n"; 
        cout << "Current temperature: " << env.compute_temp(heights[MECO_time]) / 100 << " celsius\n";
        cout << "Air density at this altitude: " << env.compute_rho(heights[MECO_time]) << "\n"; 

        double mach_num_at_MECO = fabs(current_speed) / env.speed_of_sound(heights[MECO_time]);

        cout << "Current mach number: " << mach_num_at_MECO << "\n";
        summary.MECO_mach_num = mach_num_at_MECO;

        cout << "Calculating wait time until phase 2...\n";

        BallisticParams bp; 
        bp.A = 0.08; //cross sectional area
        bp.m = 255; //mass at MECO
        bp.Cd_const = 0.50; // constant here, set to <= zero for a simple LUT 

        double wait_s = wait_time_piecewise(env, bp, heights[MECO_time],current_speed,
                /*dt*/ 0.5, /*max-time*/ 60.0);

        cout << "Wait " << wait_s << " seconds\n";
        summary.wait_time = wait_s;

        cout << "Begin phase 2\n";

        j = MECO_time + (static_cast<int>(wait_s) * 100);
    }


    cout << setw(10) << left << "Meters"; 
    cout << setw(10) << left << "mbar 1";
    cout << setw(10) << left << "mbar 2";
    cout << setw(10) << left << "Seconds";
    // cout << setw(10) << left << "Buffer 'slope'\n";

    while(info.apogee_flag == false)
    {
        double current_height = heights[j];

        read_detect_decide(j, current_height, device_package, info, detect, env, summary);

        //using this index variable 'j' to cycle through the values in height_data.txt
        //Note 
        //MASTRAN data for some reason skips to sampling every 0.05 seconds instead of 0.01 seconds 
        //almost immediately after apogee. 
        //That's why I update the loop variable i += 1 instead of i += 5 after index 7722 (apogee)
        //In the AD system for the flight computer, we DONT wan't to do this.
        //Thus, the time column (column 4 is not accurate after apogee, so just count the number of steps 
        //until Apogee Detected is printed to the screen. Roughly 25 steps is 2.5 seconds). 
        if(j < 7722)
            j += 5;
        else
            j += 1;
    }

    while(info.drogue_flag == false)
    {
        double current_height = heights[j];

        read_detect_decide(j, current_height, device_package, info, detect, env, summary);

        j += 5;
    }

    while(info.main_flag == false)
    {
        double current_height = heights[j];

        read_detect_decide(j, current_height, device_package, info, detect, env, summary);

        j+= 5;
    }

    for(; j < heights.size(); j += 5)
    {
        cout << heights[j] << "\n";
    }
    
    cout << "Flight is over!\n";

    write_output_file(info, summary);
}

int main()
{
    launch();
    
}

